#include "stm32f446xx.h"

// define the gpio port and pin for the onboard led
#define LED_PORT GPIOA
#define LED_PIN  5
#define LED_PIN_POS  (1<< LED_PIN) // setting the led pin to enable

// defining port for internal button
#define BUTTON_PORT GPIOC
#define BUTTON_PIN  13

// define the EXTI LINE FOR THE BUTTON
#define BUTTON_EXTI_IRQ EXTI15_10_IRQn


// Define the timer we'll use
#define TIMER       TIM2
#define TIMER_IRQ   TIM2_IRQn

// define the interrupt period in milliseconds
#define PERIOD_MS  500


// //initializing the gpio functions
// void init_gpio(void)
// {
//     RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; // enablin the rccc clock for the ahb1 peripheral bus

//     // configure the PAS% as gneral purpos input-output pin
//     // clear the mode bits(bits 10 and 11)
//     LED_PORT->MODER &= ~(GPIO_MODER_MODE5_Msk);// i'm choosing a port then choosing register for that port then resetting them using &= ~() mask 
//     LED_PORT->MODER |= GPIO_MODER_MODER5_0; // setting as output mode 
// }

// //initializing the timer functions

// void init_timer(void)
// {
//     // Enable the clock for TIM2
//     RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; // enabling the rcc for apb1 bus

    
//     // Set the Prescaler to get a 1 kHz counter clock from 16 MHz
//     TIMER->PSC = 15999;

//     // Set the Auto-Reload Register for a 500ms period
//     // 1000 Hz / (1 / 0.5s) = 500. So ARR = 500 - 1 = 499
//     TIMER->ARR = 499; // auto reload register
//     //arr means auto reload register

//     // Enable the update interrupt (UIE)

//     TIMER->DIER |= TIM_DIER_UIE; // dma/interrupt reload register, eie menas update interrupt enable.
    
//     // Enable the TIM2 interrupt in the Nested Vector Interrupt Controller (NVIC)
//     NVIC_EnableIRQ(TIMER_IRQ); // irq means interrupt request.

//     // start the timer
//     TIMER->CR1 |= TIM_CR1_CEN;
// }

// void TIM2_IRQHandler(void)
// {
//     // Check if the update interrupt flag is set

//     if (TIMER->SR & TIM_SR_UIF) // uif means update inteerupt flag
//     {
//         TIMER->SR &= ~(TIM_SR_UIF);// clearing the interrupt flag in this 

//         //TOGGLE THE LED PIN USING THE XOR OPERATOR
//         LED_PORT->ODR ^= LED_PIN_POS;
//     }
// }


// int main(void)
// {
//     // initialize the gpio and time peripherals
//     init_gpio();
//     init_timer();

//     while (1)
//     {

//     }
    
//     return 0;
// }



//function prototypes
void init_gpio(void);
void init_button_exti(void);

// main function
int main(void)
{
    init_gpio();
    init_button_exti();

    while (1)
    {
        /* code */
    }
   
}

void init_gpio(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;// ENABLING THE AHB 1 BUS FOR GPIOA

    //CONFIGURING THE PAS5 INTERNAL LED AS THE OUTPUT PIN
    LED_PORT->MODER &= ~(GPIO_MODER_MODER5_Msk); // THIS SETS THE PORT A MASK FOR IT 

    LED_PORT->MODER |= GPIO_MODER_MODER5_0;// THIS ETS THE PIN TO OUTPUT MODE

}


void init_button_exti(void)
{
    // 1. Enable the clock for GPIOC (for the button) and SYSCFG (for EXTI)

    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN; // ENABLING THE AHB1 BUS GPIOC PORT
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; // ENABLING THE APB2 BUS SYSTEMCONFIG FOR EXTERNAL INTERUPTS 1

    // 2. Configure PC13 as an input (this is its default state, but good practice to be explicit)
    // Clear the mode bits (26 and 27) for PC13 to '00' for input mode
    BUTTON_PORT->MODER &= ~(GPIO_MODER_MODER13_Msk);// USING MASK TO CLEAR THE REGISTER 
    // 3. Select the source input for the EXTI line.
    // The SYSCFG_EXTICR4 register controls EXTI lines 12-15.
    // We need to set the EXTI13 field to select GPIOC.
    // The value 0b0010 (2) corresponds to GPIOC.
    // Clear the bits first to be safe
    SYSCFG->EXTICR[3] &= ~(SYSCFG_EXTICR4_EXTI13_Msk);
    // THEN SET THE BITS FOR GPIOC
    SYSCFG->EXTICR[3] |= SYSCFG_EXTICR4_EXTI13_PC;
    // 4. Configure the EXTI line to trigger on a falling edge.
    // Falling Trigger Selection Register (FTSR)
    EXTI->FTSR |= EXTI_FTSR_FT13;
    


}
