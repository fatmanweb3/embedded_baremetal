#include "stm32f446xx.h"

// Simple delay function (to be adjusted after clock config)
void delay_ms(uint32_t ms) {
    for (volatile uint32_t i = 0; i < ms * 3000; i++) {
        __NOP(); // No operation
    }
}

// System clock configuration
void SystemClock_Config(void) {
    // Step 1: Enable HSE (8 MHz external crystal on NUCLEO-F446RE)
    RCC->CR |= RCC_CR_HSEON; // Enable HSE
    while (!(RCC->CR & RCC_CR_HSERDY)); // Wait until HSE is ready

    // Step 2: Configure PLL
    // PLLM = 8, PLLN = 360, PLLP = 2 -> 8 MHz * (360 / 8) / 2 = 180 MHz
    RCC->PLLCFGR = (8 << RCC_PLLCFGR_PLLM_Pos) | // PLLM = 8
                   (360 << RCC_PLLCFGR_PLLN_Pos) | // PLLN = 360
                   (0b00 << RCC_PLLCFGR_PLLP_Pos) | // PLLP = 2 (div by 2)
                   RCC_PLLCFGR_PLLSRC_HSE; // PLL source = HSE

    // Step 3: Enable PLL
    RCC->CR |= RCC_CR_PLLON; // Enable PLL
    while (!(RCC->CR & RCC_CR_PLLRDY)); // Wait until PLL is ready

    // Step 4: Switch system clock to PLL
    RCC->CFGR |= RCC_CFGR_SW_PLL; // Select PLL as system clock
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL); // Wait for switch
}

int main(void) {
    // Configure system clock
    SystemClock_Config();

    // Enable clock for GPIOA
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; // Bit 0 = 1

    // Configure PA5 as output
    GPIOA->MODER &= ~(GPIO_MODER_MODER5); // Clear bits 11:10
    GPIOA->MODER |= (GPIO_MODER_MODER5_0); // Set to 01 (output)

    // Infinite loop to toggle LED
    while (1) {
        GPIOA->ODR ^= GPIO_ODR_ODR5; // Toggle PA5
        delay_ms(500); // Delay ~500ms (adjust based on 180 MHz)
    }
}
