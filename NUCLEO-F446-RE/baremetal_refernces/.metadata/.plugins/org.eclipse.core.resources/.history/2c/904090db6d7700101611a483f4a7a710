#include "stm32f446xx.h"
#include "stdint.h"

#define FADE_STEPS 1001
#define TOTAL_STEPS (FADE_STEPS * 2 - 2) // 0->1000->0

uint16_t fade_pattern[TOTAL_STEPS];

void generate_fade_pattern(void) {
    // Fade up
    for (int i = 0; i < FADE_STEPS; i++) {
        fade_pattern[i] = i;
    }
    // Fade down
    for (int i = FADE_STEPS; i < TOTAL_STEPS; i++) {
        fade_pattern[i] = TOTAL_STEPS - i;
    }
}


void rcc_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

    RCC->AHB1ENR |= RCC_AHB1ENR_DMA1EN;
}


void gpio_init(void)
{
    GPIOA->MODER &= ~(GPIO_MODER_MODER5_Msk);

    GPIOA->MODER |= (2U << GPIO_MODER_MODER5_Pos);

    GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL5_Msk);// CLEARING THE PREVIOUS FUNCTIONS.

    GPIOA->AFR[0] |= (1U <<  GPIO_AFRL_AFSEL5_Pos); // 1u is replace by the alternate function tos et a n af 7 we use 7u
}


void tim2_init(void)
{
  TIM2->PSC = 15;

  TIM2->ARR = 999;

  TIM2->CCR1 = 0;



  TIM2->CCMR1 &= ~(TIM_CCMR1_OC1M_Msk); // CLEARING THE CCMR 1

  // SETTING THE CORRECT PWM MODE
  TIM2->CCMR1 |= (6U << TIM_CCMR1_OC1M_Pos); // WHY SETTING 6U IS 6U MEANS 110 IN BINARY  IN REFERENCE MANUAL IT IS PWM MODE 1 

  TIM2->CCMR1 |= TIM_CCMR1_OC1PE; // OUTPUT COMPARE PRELOAD ENABLE

  TIM2->CCER |= TIM_CCER_CC1E; // ENABLING THE CHANNEL 1 



  TIM2->CR1 |= TIM_CR1_ARPE; // AUTO RELOAD PRELOAD ENABLE

  TIM2->CR1 |= TIM_CR1_CEN; // ENABLING THE TIMER.
}

void tim3_trigger_init(void)
{
  TIM3->PSC = 15999; // 1 kHz tick
  TIM3->ARR = 10 - 1; // 10 ms per step -> 100 steps/sec

//  TIM3->CR2 &= ~(TIM_CR2_MMS_Msk);
//  TIM3->CR2 |= (2U << TIM_CR2_MMS_Pos);




  TIM3->CR1|= TIM_CR1_CEN; //  enbale irq
}

void dma_init(void)
{
  DMA1_Stream1->CR &= ~(DMA_SxCR_EN);

  DMA1_Stream1->PAR = (uint32_t)&TIM2->CCR1;
  DMA1_Stream1->M0AR = (uint32_t)fade_pattern;
  DMA1_Stream1->NDTR = TOTAL_STEPS;

  DMA1_Stream1->CR =
    (5U << DMA_SxCR_CHSEL_Pos) |
    DMA_SxCR_PL_1 |  // Priority high
    DMA_SxCR_MSIZE_0 | // Memory size = 16-bit
    DMA_SxCR_PSIZE_0 | // Peripheral size = 16-bit
    DMA_SxCR_MINC | // Increment memory address
    DMA_SxCR_CIRC | // Circular mode
    DMA_SxCR_DIR_0; // Memory-to-peripheral
  
  DMA1_Stream1->FCR = 0; //Direct mode

  // Link TIM3 update event to DMA request
  TIM3->DIER |= TIM_DIER_UDE; // DMA request on update

  DMA1_Stream1->CR |= DMA_SxCR_EN; // Enable DMA
}


int main(void)
{
	generate_fade_pattern();
    rcc_init();
    gpio_init();
    tim2_init();
    tim3_trigger_init();
    dma_init();

    while(1)
    {
      
    }
}

