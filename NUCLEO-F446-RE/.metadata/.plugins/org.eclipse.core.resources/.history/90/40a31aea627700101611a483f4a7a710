#include "stm32f446xx.h"
#include "stdint.h"


void rcc_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
}

void gpio_init(void)
{
    GPIOA->MODER &= ~(GPIO_MODER_MODER5_Msk);

    GPIOA->MODER |= (1U << GPIO_MODER_MODER5_Pos); // WHY SETTING 1 IS I'M NOT GENRATING A LTERNAT FUNCTION LIEK PWM TO PAS5 I'M JUST TOGGLING LED USING TIMER INTERRUPTS.

    GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL5_Msk);// CLEARING THE PREVIOUS FUNCTIONS.

    GPIOA->AFR[0] |= (1U <<  GPIO_AFRL_AFSEL5_Pos); // 1u is replace by the alternate function tos et a n af 7 we use 7u
}

void tim2_init(void)
{
  TIM2->PSC = 15;

  TIM2->ARR = 9999;

  TIM2->CCR1 = 0;;

  TIM2->CCMR1 &= ~(TIM_CCMR1_OC1M_Msk); // CLEARING THE CCMR 1

  // SETTING THE CORRECT PWM MODE
  TIM2->CCMR1 |= (6U << TIM_CCMR1_OC1M_Pos); // WHY SETTING 6U IS 6U MEANS 110 IN BINARY  IN REFERENCE MANUAL IT IS PWM MODE 1 

  TIM2->CCMR1 |= TIM_CCMR1_OC1PE; // OUTPUT COMPARE PRELOAD ENABLE

  TIM2->CCER |= TIM_CCER_CC1E; // ENABLING THE CHANNEL 1 

  TIM2->CR1 |= TIM_CR1_ARPE; // AUTO RELOAD PRELOAD ENABLE

  TIM2->CR1 |= TIM_CR1_CEN; // ENABLING THE TIMER.
}

// void TIM2_IRQHandler(void)
// {
//     if (TIM2->SR & TIM_SR_UIF)
//     {
//         TIM2->SR &= ~(TIM_SR_UIF);
//         GPIOA->ODR ^= 1U << GPIO_ODR_OD5_Pos;
//     }
// }

int main(void)
{
    rcc_init();
    gpio_init();
    tim2_init();

    while(1)
    {

      for(uint32_t duty = 0; duty <= 1000; duty ++)
      {
        TIM2->CCR1 = duty;
        for( volatile int i = 0; i < 1000; i++); // delay
      }

      // fade down

      for(uint32_t duty = 1000; duty > 0; duty--)
      {
        TIM2->CCR1 = duty;
        for (volatile int i = 0; i<1000; i++);
      }

    }
}

