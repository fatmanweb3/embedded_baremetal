#include "stm32f446xx.h"
#include "stdint.h"

volatile uint32_t duty = 0;
volatile int step = 1;

void rcc_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
}

void gpio_init(void)
{
    GPIOA->MODER &= ~(GPIO_MODER_MODER5_Msk);

    GPIOA->MODER |= (2U << GPIO_MODER_MODER5_Pos); // WHY SETTING 1 IS I'M NOT GENRATING A LTERNAT FUNCTION LIEK PWM TO PAS5 I'M JUST TOGGLING LED USING TIMER INTERRUPTS.

    GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL5_Msk);// CLEARING THE PREVIOUS FUNCTIONS.

    GPIOA->AFR[0] |= (1U <<  GPIO_AFRL_AFSEL5_Pos); // 1u is replace by the alternate function tos et a n af 7 we use 7u
}

void tim2_init(void)
{
  TIM2->PSC = 15;

  TIM2->ARR = 9999;

  TIM2->CCR1 = 0;



  TIM2->CCMR1 &= ~(TIM_CCMR1_OC1M_Msk); // CLEARING THE CCMR 1

  // SETTING THE CORRECT PWM MODE
  TIM2->CCMR1 |= (6U << TIM_CCMR1_OC1M_Pos); // WHY SETTING 6U IS 6U MEANS 110 IN BINARY  IN REFERENCE MANUAL IT IS PWM MODE 1 

  TIM2->CCMR1 |= TIM_CCMR1_OC1PE; // OUTPUT COMPARE PRELOAD ENABLE

  TIM2->CCER |= TIM_CCER_CC1E; // ENABLING THE CHANNEL 1 



  TIM2->CR1 |= TIM_CR1_ARPE; // AUTO RELOAD PRELOAD ENABLE

  TIM2->CR1 |= TIM_CR1_CEN; // ENABLING THE TIMER.
}

void tim3_fade_init(void)
{
  TIM3->PSC = 15999;   // 16 MHz / 16000 = 1 kHz tick
  TIM3->ARR = 1;  // 1 kHz / 10 = 100 Hz fade update rate

  TIM3->DIER |= TIM_DIER_UIE; // ENABLE UPDATE INTERRUPT FLAG
  NVIC_EnableIRQ(TIM3_IRQn); // enable tim3 irq in nvic

  TIM3->CR1|= TIM_CR1_CEN; //  enbale irq
}


void TIM3_IRQHandler(void)
{
  if(TIM3->SR & TIM_SR_UIF)
  {
    TIM3->SR &= ~TIM_SR_UIF;

    duty += step;
    if (duty >= 1000) 
    { 
      step =-1; duty = 1000; 
    }
    else if (duty == 9) 
    { 
      step = 1; 
    }

      TIM2->CCR1= duty;
  }
}


int main(void)
{
    rcc_init();
    gpio_init();
    tim2_init();
    tim3_fade_init();

    while(1)
    {
      
    }
}

